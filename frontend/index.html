<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOTO Store Finder</title>

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet MarkerCluster CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

    <!-- Leaflet Control Geocoder CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.css" />

    <style>
        :root {
            --soto-green-primary: #6B9F3E;
            --soto-green-dark: #4F7B2E;
            --soto-green-light: #8AB860;
            --soto-gold: #C9A961;
            --soto-cream: #FAF8F3;
            --soto-brown: #5D4E37;
            --soto-text-dark: #2C2C2C;
            --soto-text-light: #6B6B6B;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--soto-cream);
            color: var(--soto-text-dark);
        }

        .header {
            background: linear-gradient(135deg, var(--soto-green-primary) 0%, var(--soto-green-dark) 100%);
            color: white;
            padding: 24px 32px;
            box-shadow: 0 4px 12px rgba(107, 159, 62, 0.15);
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border-radius: 50%;
        }

        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 6px;
            letter-spacing: -0.5px;
            position: relative;
            z-index: 1;
        }

        .header p {
            font-size: 15px;
            opacity: 0.95;
            font-weight: 400;
            position: relative;
            z-index: 1;
        }

        .stats {
            background: white;
            padding: 18px 32px;
            display: flex;
            gap: 40px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.06);
            border-bottom: 2px solid var(--soto-cream);
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .stat-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--soto-green-primary) 0%, var(--soto-green-light) 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 22px;
            box-shadow: 0 2px 8px rgba(107, 159, 62, 0.2);
        }

        .stat-info h3 {
            font-size: 28px;
            font-weight: 700;
            color: var(--soto-green-dark);
            letter-spacing: -0.5px;
        }

        .stat-info p {
            font-size: 13px;
            color: var(--soto-text-light);
            margin-top: 2px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        #map {
            height: calc(100vh - 180px);
            width: 100%;
        }

        .leaflet-popup-content-wrapper {
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(107, 159, 62, 0.15);
            border: 1px solid var(--soto-cream);
        }

        .popup-content {
            min-width: 260px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .popup-header {
            font-size: 17px;
            font-weight: 700;
            color: var(--soto-green-dark);
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 3px solid var(--soto-green-primary);
            letter-spacing: -0.3px;
        }

        .popup-section {
            margin: 12px 0;
        }

        .popup-section strong {
            display: block;
            color: var(--soto-text-light);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .popup-section p {
            color: var(--soto-text-dark);
            font-size: 14px;
            line-height: 1.6;
        }

        .popup-hours {
            background: var(--soto-cream);
            padding: 10px 12px;
            border-radius: 8px;
            margin-top: 6px;
            border: 1px solid rgba(107, 159, 62, 0.1);
        }

        .popup-hours-item {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            padding: 6px 8px;
            margin: 2px 0;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .popup-hours-item.today {
            background: linear-gradient(135deg, var(--soto-green-primary) 0%, var(--soto-green-dark) 100%);
            color: white;
            font-weight: 700;
            box-shadow: 0 2px 6px rgba(107, 159, 62, 0.3);
        }

        .popup-hours-day {
            color: var(--soto-text-light);
            font-weight: 500;
        }

        .popup-hours-item.today .popup-hours-day {
            color: white;
            font-weight: 700;
        }

        .popup-hours-time {
            color: var(--soto-green-dark);
            font-weight: 600;
        }

        .popup-hours-item.today .popup-hours-time {
            color: white;
            font-weight: 700;
        }

        /* Geocoder Search Box Styling */
        .leaflet-control-geocoder {
            border-radius: 12px !important;
            box-shadow: 0 4px 12px rgba(107, 159, 62, 0.2) !important;
            border: 2px solid var(--soto-green-primary) !important;
        }

        .leaflet-control-geocoder-form {
            border-radius: 10px !important;
        }

        .leaflet-control-geocoder-form input {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
            font-size: 14px !important;
            padding: 10px 12px !important;
            border: none !important;
            border-radius: 8px !important;
            color: var(--soto-text-dark) !important;
        }

        .leaflet-control-geocoder-form input:focus {
            outline: none !important;
            box-shadow: 0 0 0 3px rgba(107, 159, 62, 0.2) !important;
        }

        .leaflet-control-geocoder-alternatives {
            background: white !important;
            border-radius: 8px !important;
            box-shadow: 0 4px 12px rgba(107, 159, 62, 0.15) !important;
            border: 1px solid var(--soto-cream) !important;
            margin-top: 4px !important;
        }

        .leaflet-control-geocoder-alternatives a {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
            font-size: 13px !important;
            padding: 10px 12px !important;
            color: var(--soto-text-dark) !important;
            border-bottom: 1px solid var(--soto-cream) !important;
        }

        .leaflet-control-geocoder-alternatives a:hover {
            background: var(--soto-cream) !important;
            color: var(--soto-green-dark) !important;
        }

        .leaflet-control-geocoder-alternatives a:first-child {
            border-radius: 8px 8px 0 0 !important;
        }

        .leaflet-control-geocoder-alternatives a:last-child {
            border-radius: 0 0 8px 8px !important;
            border-bottom: none !important;
        }

        .leaflet-control-geocoder-icon {
            background-color: var(--soto-green-primary) !important;
            border-radius: 8px !important;
        }

        .leaflet-control-geocoder-icon:hover {
            background-color: var(--soto-green-dark) !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåø SOTO Store Finder</h1>
        <p>Nat√ºrlich. Einfach. Bio. ‚Äì Finde SOTO Produkte in deiner N√§he</p>
    </div>

    <div class="stats">
        <div class="stat">
            <div class="stat-icon">üè™</div>
            <div class="stat-info">
                <h3 id="store-count">-</h3>
                <p>Filialen</p>
            </div>
        </div>
        <div class="stat">
            <div class="stat-icon">üìç</div>
            <div class="stat-info">
                <h3 id="city-count">-</h3>
                <p>St√§dte</p>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet MarkerCluster JavaScript -->
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <!-- Leaflet Control Geocoder JavaScript -->
    <script src="https://unpkg.com/leaflet-control-geocoder@2.4.0/dist/Control.Geocoder.js"></script>

    <script>
        // Initialize map centered on Germany (fallback position)
        const map = L.map('map').setView([51.1657, 10.4515], 6);

        // Add OpenStreetMap tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        }).addTo(map);

        // Track if user location was found (prevents fitBounds from overriding)
        let userLocationFound = false;
        let userLocationMarker = null;

        // Use Leaflet's native locate method for better reliability
        function tryGeolocation() {
            console.log('Attempting to get user location...');

            map.locate({
                setView: false,  // We'll set view manually for better control
                maxZoom: 12,
                timeout: 10000,
                enableHighAccuracy: false,
                watch: false
            });
        }

        // Handle successful location
        map.on('locationfound', function(e) {
            console.log('Location found:', e.latlng);
            userLocationFound = true;

            // Zoom to user location
            map.setView(e.latlng, 12);

            // Add blue circle marker for user location
            userLocationMarker = L.circleMarker(e.latlng, {
                radius: 10,
                fillColor: '#4285F4',
                color: '#ffffff',
                weight: 3,
                opacity: 1,
                fillOpacity: 0.7
            }).addTo(map);

            // Add accuracy circle
            L.circle(e.latlng, {
                radius: e.accuracy,
                color: '#4285F4',
                fillColor: '#4285F4',
                fillOpacity: 0.1,
                weight: 1
            }).addTo(map);

            userLocationMarker.bindPopup('üìç Dein Standort').openPopup();
            console.log('User location marker added successfully');
        });

        // Handle location error - fallback to IP geolocation
        map.on('locationerror', function(e) {
            console.warn('Geolocation error:', e.message);
            tryIPGeolocation();
        });

        // Fallback: Try to get approximate location from IP address
        function tryIPGeolocation() {
            console.log('Trying IP-based geolocation...');
            fetch('https://ipapi.co/json/')
                .then(response => response.json())
                .then(data => {
                    if (data.latitude && data.longitude) {
                        console.log('IP location found:', data.city, data.country_name);
                        const ipLocation = L.latLng(data.latitude, data.longitude);
                        map.setView(ipLocation, 10);
                        userLocationFound = true;

                        // Add marker for IP-based location
                        userLocationMarker = L.circleMarker(ipLocation, {
                            radius: 8,
                            fillColor: '#FFA500',
                            color: '#ffffff',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.6
                        }).addTo(map);

                        userLocationMarker.bindPopup('üìç Ungef√§hrer Standort (IP-basiert)');
                    } else {
                        console.warn('IP geolocation failed, using default Germany view');
                    }
                })
                .catch(error => {
                    console.warn('IP geolocation error:', error.message);
                    console.log('Using default Germany view');
                });
        }

        // Start geolocation attempt immediately
        tryGeolocation();

        // Add search/geocoder control
        const geocoder = L.Control.Geocoder.nominatim({
            geocodingQueryParams: {
                countrycodes: 'de',  // Limit search to Germany
                addressdetails: 1,
                limit: 5
            }
        });

        const geocoderControl = L.Control.geocoder({
            geocoder: geocoder,
            defaultMarkGeocode: false,  // Don't add default marker
            placeholder: 'Adresse oder PLZ suchen...',
            errorMessage: 'Keine Ergebnisse gefunden',
            collapsed: false,  // Keep search box expanded
            position: 'topright'
        }).addTo(map);

        // Handle geocoding results
        geocoderControl.on('markgeocode', function(e) {
            const latlng = e.geocode.center;
            const bbox = e.geocode.bbox;

            console.log('Search result:', e.geocode.name);

            // Remove previous search marker if exists
            if (window.searchMarker) {
                map.removeLayer(window.searchMarker);
            }

            // Add green marker for searched location
            window.searchMarker = L.circleMarker(latlng, {
                radius: 8,
                fillColor: '#6B9F3E',  // SOTO green
                color: '#ffffff',
                weight: 2,
                opacity: 1,
                fillOpacity: 0.8
            }).addTo(map);

            window.searchMarker.bindPopup('üîç ' + e.geocode.name).openPopup();

            // Zoom to the result
            if (bbox) {
                map.fitBounds(bbox, { padding: [50, 50], maxZoom: 14 });
            } else {
                map.setView(latlng, 13);
            }
        });

        // Custom icons for each chain
        const dennsIcon = L.icon({
            iconUrl: 'images/denns-marker.svg',
            iconSize: [40, 50],
            iconAnchor: [20, 50],
            popupAnchor: [0, -50]
        });

        const alnaturaIcon = L.icon({
            iconUrl: 'images/alnatura-marker.svg',
            iconSize: [40, 50],
            iconAnchor: [20, 50],
            popupAnchor: [0, -50]
        });

        const tegutIcon = L.icon({
            iconUrl: 'images/tegut-marker.svg',
            iconSize: [40, 50],
            iconAnchor: [20, 50],
            popupAnchor: [0, -50]
        });

        const vollcornerIcon = L.icon({
            iconUrl: 'images/vollcorner-marker.svg',
            iconSize: [40, 50],
            iconAnchor: [20, 50],
            popupAnchor: [0, -50]
        });

        // Function to get icon based on chain
        function getChainIcon(chainId) {
            switch(chainId) {
                case 'denns':
                    return dennsIcon;
                case 'alnatura':
                    return alnaturaIcon;
                case 'tegut':
                    return tegutIcon;
                case 'vollcorner':
                    return vollcornerIcon;
                default:
                    return dennsIcon; // fallback
            }
        }

        // Create marker cluster group
        const markers = L.markerClusterGroup({
            maxClusterRadius: 50,
            spiderfyOnMaxZoom: true,
            showCoverageOnHover: false,
            zoomToBoundsOnClick: true
        });

        // Load and display GeoJSON data
        fetch('stores.geojson')
            .then(response => response.json())
            .then(data => {
                const cities = new Set();

                data.features.forEach(feature => {
                    const props = feature.properties;
                    cities.add(props.city);

                    // Create popup content
                    let popupContent = `
                        <div class="popup-content">
                            <div class="popup-header">${props.name}</div>

                            <div class="popup-section">
                                <strong>üìç Adresse</strong>
                                <p>${props.address}</p>
                            </div>
                    `;

                    // Opening hours
                    if (props.opening_hours) {
                        // Always show structured format with all 7 days
                        const days = ['Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag', 'Sonntag'];
                        const today = days[new Date().getDay() === 0 ? 6 : new Date().getDay() - 1];

                        let hoursHtml = '<div class="popup-section"><strong>üïê √ñffnungszeiten</strong><div class="popup-hours">';

                        // Check if it's text format (Alnatura) - parse and convert to structured display
                        if (props.opening_hours.text) {
                            const text = props.opening_hours.text;

                            // Parse the text to extract time and day range
                            // Common patterns: "Mo-Sa 8-20 Uhr", "Mo-Fr 9-18 Uhr", etc.
                            const timeMatch = text.match(/(\d{1,2})[:\-]?(\d{0,2})\s*[-‚Äì]\s*(\d{1,2})[:\-]?(\d{0,2})/);
                            let timeText = text; // fallback to full text

                            if (timeMatch) {
                                const openHour = timeMatch[1].padStart(2, '0');
                                const openMin = (timeMatch[2] || '00').padStart(2, '0');
                                const closeHour = timeMatch[3].padStart(2, '0');
                                const closeMin = (timeMatch[4] || '00').padStart(2, '0');
                                timeText = `${openHour}:${openMin} - ${closeHour}:${closeMin}`;
                            }

                            // Detect which days are open based on text pattern
                            const isMoSa = /Mo-Sa/i.test(text);
                            const isMoFr = /Mo-Fr/i.test(text);

                            days.forEach(day => {
                                const isToday = day === today;
                                const todayClass = isToday ? 'today' : '';

                                let displayTime;
                                if (day === 'Sonntag' && (isMoSa || isMoFr)) {
                                    displayTime = 'geschlossen';
                                } else if (day === 'Samstag' && isMoFr) {
                                    displayTime = 'geschlossen';
                                } else {
                                    displayTime = timeText;
                                }

                                hoursHtml += `
                                    <div class="popup-hours-item ${todayClass}">
                                        <span class="popup-hours-day">${day}</span>
                                        <span class="popup-hours-time">${displayTime}</span>
                                    </div>
                                `;
                            });
                        } else {
                            // Structured format - show all days, "geschlossen" for missing
                            days.forEach(day => {
                                const isToday = day === today;
                                const todayClass = isToday ? 'today' : '';

                                let timeText;
                                if (props.opening_hours[day]) {
                                    const hours = props.opening_hours[day];
                                    timeText = `${hours.open_from} - ${hours.open_until}`;
                                } else {
                                    timeText = 'geschlossen';
                                }

                                hoursHtml += `
                                    <div class="popup-hours-item ${todayClass}">
                                        <span class="popup-hours-day">${day}</span>
                                        <span class="popup-hours-time">${timeText}</span>
                                    </div>
                                `;
                            });
                        }

                        hoursHtml += '</div></div>';
                        popupContent += hoursHtml;
                    }

                    popupContent += '</div>';

                    // Create marker with chain-specific icon
                    const chainIcon = getChainIcon(props.chain_id);
                    const marker = L.marker(
                        [feature.geometry.coordinates[1], feature.geometry.coordinates[0]],
                        { icon: chainIcon }
                    ).bindPopup(popupContent);

                    markers.addLayer(marker);
                });

                // Add markers to map
                map.addLayer(markers);

                // Update statistics
                document.getElementById('store-count').textContent = data.features.length;
                document.getElementById('city-count').textContent = cities.size;

                // Only fit bounds to all markers if user location was not found
                // This prevents overriding the user's location zoom
                if (data.features.length > 0 && !userLocationFound) {
                    map.fitBounds(markers.getBounds(), { padding: [50, 50] });
                }
            })
            .catch(error => {
                console.error('Error loading stores:', error);
            });
    </script>
</body>
</html>
